几种排序比较：
插入排序:        平均            最好        最坏                           空间复杂度              稳点性
             直接插入        o(n^2)   o(n)   o(n^2)     o(1)       稳点  
             希尔排序    o(n^1.25) o(n)    o(n^2)     o(1)      不稳定
选择排序:
             直接选择        o(n^2)   o(n^2)    o(n^2)     o(1)      不稳点
              堆排序           o(nlogn) o(nlogn)  o(nlogn)   o(1)      不稳定
比较排序:
             冒泡排序         o(n^2)    o(n)      o(n^2)     o(1)       稳点    
             快速排序         o(nlogn)  o(nlogn)  o(n^2)     o(logn)    不稳定
             归并排序         o(nlogn)  o(nlogn)  o(nlogn)   o(n)       稳定     
            基数排序          o(d(r+n)) o(d(r+n)) o(d(r+n))  o(rd+n)    稳定                                                                                                                  稳定的
       
****空间复杂度:就是关于辅助内存的 ,所需要的存储空间大小
    o(1):的几种排序需要一个临时变量
    o(logn): 快速排序 需要递归调用 需要将数组分成两个子数组一大一小
    o(n):归并排序注意需要借助一个辅助数组//基数排序也是o(n)
****稳点性:两个相等数的位置在排序前和排序后其相对位置是否发生改变
            冒泡   归并   直接插入 
****原地排序:
          只有归并排序不是原地排序


            
***快速排序：(其运行效率由概率保证)
      最好复杂度：最好情况每次都能对数组对半分---(可以看逆序数最少的)
          
       最坏复杂度： 对有序的数列或者逆序效率非常低 近似冒泡 1+2+3+……n-1+n=n(n-1)/2  ~o(n^2) 
                               随机打乱数组可以预防这种情况        
       平均复杂度： 2NInN==1.39NlgN  是最好的情况1.39倍(1/6交换)
                              其系数比其他线性对数级别的排序算法小  三向切分达到线性级别
 
        三向切分的快速排序:最坏情况当所以主键均不相同时候,当出现重复的时候其性能比归并排序好,
               实际情况中其包含大量重复元素，从线性对数级降到了线性级，  
                              
***堆排序
       最坏复杂度：~2NlgN
       最好平均都是：2NlgN+2N  
        同时最优的利用时间空间,但是该排序无法利用缓存,很少和相邻元素进行比较
        第一次排序之后 数组一定要满足是一个堆              
***归并排序
     书上写的最好最坏平均都是：o(nlogn) 
     自顶向下：0.5NlgN~NlgN
  merge sort 1.2 times faster than shell sort
***希尔排序   比插入排序速度快,希尔：有一点排序的数组进行插入排序
         但希尔排序时间复杂度与增量的选择有关
    
    
***冒泡
        一般使用冒泡排序时候 都采用改进的，设置一个标志位flag，将其初始值为false表示无序的表
       在排序之前设置true   交换数据时更改false  在新一轮排序之前检查flag如果true,
       表示上一次没有交换数据，结束排序。否则进行排序
       如果是正序则只进行一次
  //在一次比较中如果未发生交换可以提前结束
 
***选择(和初始状态无关，有序全等随机一样//一定数据最少)----从未排序里面找出来
         平均复杂度：n^2/2比较  N次交换
   (对于随机无重复数组插入和选择都是平方级的)
 
***插入(和初始状态关系很大)----按顺序找到按顺序排
          最好情况：已经有序了 n-1   0次交换 
         平均复杂度 ：n^2/4
         最坏情况：n^2/2 
   (插入排序是选择排序的1.7倍,当前所以左侧是有序的)
 
 几种排序扩展：
***快速排序新排法:
        遇到最后一个和切分数一样第一次不要动  当右子数组排序时便移到中间了 
   1 左边第一大的和右边第一个小的交换
   2 先找到右边第一个小的放在切分位置 然后依次补空位置
        针对快速排序减少递归深度:每次分区后先处理短的那一部分,递归深度可以理解为系统栈保存的深度
       先处理小的那部分 栈的深度会比较小 如果处理长的部分 不断递归压入栈使其深度变得更长
   
   
   
   
   
   
***基数排序 可以并行处理可以把问题划分几部分处理
         不仅对小范围整数 还可以操作字符
         拓扑排序是图论里面的--不可以排数据
         
             
***第一次排序一个元素可以放在最终位置：
   /冒泡-最大 /选择-最小的/快速-中间/堆-最大/
        希尔和插入和归并不满足

***直接插入排序最好的情况每次将数插入最后的位置  o(n)
         快速排序最好情况每次将数组分为两部分，递归，o(nlogn)
         冒泡排序最好的情况正序 o(n)
   时间复杂度与记录的初始排序无关:堆排序    希尔排序   归并   折半排序--
                                                                  折半插入排序:           
   比较次数和初始元素序列排序无关:特例 改变的冒泡排序比较次数与其有关     

*比较排序都和初始序列有关//初始顺序不一样  
     



 
 
***内部排序与外部排序
   外部:待排序的文件很大,无法同时调入内存进行排序==内外存交换+内部归并
    I/O交换效率:  内存的操作速度远高于外设，影响外部排序主要因素是内存与外设交换信息的数量
           内部排序通常是多路归并，将文件分成多个能一次装入内存的部分  //归并躺数：logkN==K路数 N段数     
    *归并躺数决定外部读取文件的次数，为了减少读取次数1增加归并路数2减少N段数，置换选择排序
            为了增加初始归并段长度从而降低了归并段数     
    工作原理:
          从fi待排序文件处输入n个记录到内存工作区w---从工作区w处选择关键字minrecord
    ---将这些记录输出到输出文件fo---如果fi不为空在输入下一个记录到w区
    ---选出剩余最小的更新为minrecord
    ----不断重复3~4直到w工作区里面不产生新的minrecord得到一个初始归并段
    ----不断重复2~6直到w为空
            如果fi是一组已经排好顺序的数,minrecord一定一直更新 ,直接使得fo=n
    
   
    
             
   内部:完全放在内存内进行的排序  ----一般指的排序是内部排序--快速 /归并/堆
             不分顺序存储和链式存储 
    
****基于比较的方法最坏情况下时间复杂度下限:logn!约等于nlogn(基于比较的算法没有少于这些次比较的)    
 1  对于n个元素 在比较树里面有n!种排序//2^h高度为h的数叶节点的数量
           由一颗比较树可知-----N!<=树的叶子节点数<=2^h--------h>=logN!(nlogn)
            即使最好的算法在最坏的情况下也需要nlogn次比较
   (另一种见解:对于n个数未排序之前有n!种可能情况，每次比较晚n!/2---m次比较后
    n!/2^m<=1时候排序结束  此时比较次数m=logn!=nlogn)        
            例子(一个n/k个每一个都是k个元素  o(n/k*klogk)=o(nlog2K))       
 2  平均的来说   基于切分的选择算法运行时间是线性级别的,但是最坏的情况下运行时间是平方级的
           但是与快速排序一致,将数组乱序可以防止这种情况发生       
       
***将两个各有n个有序元素的有序表合并成一个有序表:
最好情况:其中一个表中元素全部小于另一个表///a2[0]和a[0--n]共n次
最坏情况:两个表是交叉的a[0]~a2[0]a2[1]//…………a[n]~a2[n]a2[n+1]共2n-1次   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     